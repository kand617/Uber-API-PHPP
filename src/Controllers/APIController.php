<?php
/*
 * UberAPILib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ) on 12/13/2016
 */

namespace UberAPILib\Controllers;

use UberAPILib\APIException;
use UberAPILib\APIHelper;
use UberAPILib\Configuration;
use UberAPILib\Models;
use UberAPILib\Exceptions;
use UberAPILib\Http\HttpRequest;
use UberAPILib\Http\HttpResponse;
use UberAPILib\Http\HttpMethod;
use UberAPILib\Http\HttpContext;
use Unirest\Request;

/**
 * @todo Add a general description for this controller.
 */
class APIController extends BaseController {

    /**
     * @var APIController The reference to *Singleton* instance of this class
     */
    private static $instance;
    
    /**
     * Returns the *Singleton* instance of this class.
     * @return APIController The *Singleton* instance.
     */
    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static();
        }
        
        return static::$instance;
    }

    /**
     * Get a map with a visual representation of a Request.
     * @param  string     $requestId      Required parameter: Unique identifier representing a Request.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getRequestMap (
                $requestId) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/v1/requests/{request_id}/map';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'request_id' => $requestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //set HTTP basic auth parameters
        Request::auth(Configuration::$basicAuthUserName, Configuration::$basicAuthPassword);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new APIException('Malformed request.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new APIException('Unauthorized the request requires user authentication (not logged in).', $_httpContext);
        }

        else if ($response->code == 403) {
            throw new APIException('Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new APIException('Not found', $_httpContext);
        }

        else if ($response->code == 406) {
            throw new APIException('Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', $_httpContext);
        }

        else if ($response->code == 409) {
            throw new APIException('A conflict needs to be resolved before the request can be made.', $_httpContext);
        }

        else if ($response->code == 422) {
            throw new APIException('Invalid request. The request body is parse-able however with invalid content or there are issues with a rider\'s user account.', $_httpContext);
        }

        else if ($response->code == 429) {
            throw new APIException('Too Many Requests. Rate limited.', $_httpContext);
        }

        else if ($response->code == 500) {
            throw new APIException('Internal Server Error.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\RequestMapResponse());
    }
        
    /**
     * Cancel an ongoing Request on behalf of a rider.
     * @param  string     $requestId      Required parameter: Unique identifier representing a Request.
     * @return void response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteRequestCancel (
                $requestId) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/v1/requests/{request_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'request_id' => $requestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //set HTTP basic auth parameters
        Request::auth(Configuration::$basicAuthUserName, Configuration::$basicAuthPassword);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new APIException('Malformed request.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new APIException('Unauthorized the request requires user authentication (not logged in).', $_httpContext);
        }

        else if ($response->code == 403) {
            throw new APIException('Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new APIException('Not found', $_httpContext);
        }

        else if ($response->code == 406) {
            throw new APIException('Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', $_httpContext);
        }

        else if ($response->code == 409) {
            throw new APIException('A conflict needs to be resolved before the request can be made', $_httpContext);
        }

        else if ($response->code == 422) {
            throw new APIException('Invalid request. The request body is parse-able however with invalid content or there are issues with a rider\'s user account.', $_httpContext);
        }

        else if ($response->code == 429) {
            throw new APIException('Too Many Requests. Rate limited.', $_httpContext);
        }

        else if ($response->code == 500) {
            throw new APIException('Internal Server Error', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }
    }
        
    /**
     * Get the real time status of an ongoing trip that was created using the Ride Request endpoint.
     * @param  string     $requestId      Required parameter: Example: 
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getRequestDetails (
                $requestId) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/v1/requests/{request_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'request_id' => $requestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //set HTTP basic auth parameters
        Request::auth(Configuration::$basicAuthUserName, Configuration::$basicAuthPassword);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new APIException('Malformed request.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new APIException('Unauthorized the request requires user authentication (not logged in).', $_httpContext);
        }

        else if ($response->code == 403) {
            throw new APIException('Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new APIException('Not found.', $_httpContext);
        }

        else if ($response->code == 406) {
            throw new APIException('Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', $_httpContext);
        }

        else if ($response->code == 409) {
            throw new APIException('A conflict needs to be resolved before the request can be made.', $_httpContext);
        }

        else if ($response->code == 422) {
            throw new APIException('Invalid request. The request body is parse-able however with invalid content or there are issues with a rider\'s user account.', $_httpContext);
        }

        else if ($response->code == 429) {
            throw new APIException('Too Many Requests. Rate limited.', $_httpContext);
        }

        else if ($response->code == 500) {
            throw new APIException('Internal Server Error', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\RequestDetailsCollections());
    }
        
    /**
     * The User Profile endpoint returns information about the Uber user that has authorized with the application.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUserProfile () 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/v1/me';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //set HTTP basic auth parameters
        Request::auth(Configuration::$basicAuthUserName, Configuration::$basicAuthPassword);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new APIException('Malformed request.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new APIException('Unauthorized the request requires user authentication (not logged in).', $_httpContext);
        }

        else if ($response->code == 403) {
            throw new APIException('Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new APIException('Not found.', $_httpContext);
        }

        else if ($response->code == 406) {
            throw new APIException('Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', $_httpContext);
        }

        else if ($response->code == 422) {
            throw new APIException('Invalid request. The request body is parse-able however with invalid content.', $_httpContext);
        }

        else if ($response->code == 429) {
            throw new APIException('Too Many Requests. Rate limited.', $_httpContext);
        }

        else if ($response->code == 500) {
            throw new APIException('Internal Server Error.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\UserProfile());
    }
        
    /**
     * The Products endpoint returns information about the Uber products offered at a given location. The response includes the display name and other details about each product, and lists the products in the proper display order.
     * @param  array  $options    Array with all options for search
     * @param  double     $options['latitude']      Required parameter: Latitude component of location.
     * @param  double     $options['longitude']     Required parameter: Longitude component of location.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProductsTypes (
                $options) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/v1/products';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'latitude'  => $this->val($options, 'latitude'),
            'longitude' => $this->val($options, 'longitude'),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //set HTTP basic auth parameters
        Request::auth(Configuration::$basicAuthUserName, Configuration::$basicAuthPassword);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new APIException('Malformed request.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new APIException('Unauthorized the request requires user authentication (not logged in).', $_httpContext);
        }

        else if ($response->code == 403) {
            throw new APIException('Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new APIException('Not found.', $_httpContext);
        }

        else if ($response->code == 406) {
            throw new APIException('Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', $_httpContext);
        }

        else if ($response->code == 422) {
            throw new APIException('Invalid request. The request body is parse-able however with invalid content.', $_httpContext);
        }

        else if ($response->code == 429) {
            throw new APIException('Too Many Requests. Rate limited.', $_httpContext);
        }

        else if ($response->code == 500) {
            throw new APIException('Internal Server Error.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\ProductCollection());
    }
        
    /**
     * The Price Estimates endpoint returns an estimated price range for each product offered at a given location. The price estimate is provided as a formatted string with the full price range and the localized currency symbol.
     * @param  array  $options    Array with all options for search
     * @param  double     $options['endLatitude']         Required parameter: Latitude component of end location.
     * @param  double     $options['endLongitude']        Required parameter: Longitude component of end location.
     * @param  double     $options['startLatitude']       Required parameter: Latitude component of start location.
     * @param  double     $options['startLongitude']      Required parameter: Longitude component of start location.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getPriceEstimates (
                $options) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/v1/estimates/price';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'end_latitude'    => $this->val($options, 'endLatitude'),
            'end_longitude'   => $this->val($options, 'endLongitude'),
            'start_latitude'  => $this->val($options, 'startLatitude'),
            'start_longitude' => $this->val($options, 'startLongitude'),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //set HTTP basic auth parameters
        Request::auth(Configuration::$basicAuthUserName, Configuration::$basicAuthPassword);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new APIException('Malformed request.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new APIException('Unauthorized the request requires user authentication (not logged in).', $_httpContext);
        }

        else if ($response->code == 403) {
            throw new APIException('Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new APIException('Not found.', $_httpContext);
        }

        else if ($response->code == 406) {
            throw new APIException('Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', $_httpContext);
        }

        else if ($response->code == 422) {
            throw new APIException('Invalid request. The request body is parse-able however with invalid content.', $_httpContext);
        }

        else if ($response->code == 429) {
            throw new APIException('Too Many Requests. Rate limited.', $_httpContext);
        }

        else if ($response->code == 500) {
            throw new APIException('Internal Server Error.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\PriceEstimateCollection());
    }
        
    /**
     * The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs.
     * @param  array  $options    Array with all options for search
     * @param  double     $options['startLatitude']       Required parameter: Latitude component of the start location
     * @param  double     $options['startLongitude']      Required parameter: Longitude component of the start location
     * @param  string     $options['customerUuid']        Optional parameter: The customer id interested in estimate
     * @param  string     $options['productId']           Optional parameter: Id of the requested product
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getTimeEstimates (
                $options) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/v1/estimates/time';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'start_latitude'  => $this->val($options, 'startLatitude'),
            'start_longitude' => $this->val($options, 'startLongitude'),
            'customer_uuid'   => $this->val($options, 'customerUuid'),
            'product_id'      => $this->val($options, 'productId'),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //set HTTP basic auth parameters
        Request::auth(Configuration::$basicAuthUserName, Configuration::$basicAuthPassword);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new APIException('Malformed request.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new APIException('Unauthorized the request requires user authentication (not logged in).', $_httpContext);
        }

        else if ($response->code == 403) {
            throw new APIException('Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new APIException('Not found.', $_httpContext);
        }

        else if ($response->code == 406) {
            throw new APIException('Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', $_httpContext);
        }

        else if ($response->code == 422) {
            throw new APIException('Invalid request. The request body is parse-able however with invalid content.', $_httpContext);
        }

        else if ($response->code == 429) {
            throw new APIException('Too Many Requests. Rate limited.', $_httpContext);
        }

        else if ($response->code == 500) {
            throw new APIException('Internal Server Error.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\TimeEstimateCollection());
    }
        
    /**
     * The User Activity endpoint returns data about a user's lifetime activity with Uber. The response will include pickup locations and times, dropoff locations and times, the distance of past requests, and information about which products were requested.
     * @param  array  $options    Array with all options for search
     * @param  integer     $options['limit']      Required parameter: Number of items to return for pagging
     * @param  integer     $options['offset']     Required parameter: Page offset for pagging
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUserActivityV11 (
                $options) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/v1.1/history';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'limit'  => $this->val($options, 'limit'),
            'offset' => $this->val($options, 'offset'),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //set HTTP basic auth parameters
        Request::auth(Configuration::$basicAuthUserName, Configuration::$basicAuthPassword);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new APIException('Malformed request.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new APIException('Unauthorized the request requires user authentication (not logged in).', $_httpContext);
        }

        else if ($response->code == 403) {
            throw new APIException('Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new APIException('Not found.', $_httpContext);
        }

        else if ($response->code == 406) {
            throw new APIException('Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', $_httpContext);
        }

        else if ($response->code == 422) {
            throw new APIException('Invalid request. The request body is parse-able however with invalid content.', $_httpContext);
        }

        else if ($response->code == 429) {
            throw new APIException('Too Many Requests. Rate limited.', $_httpContext);
        }

        else if ($response->code == 500) {
            throw new APIException('Internal Server Error.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\UserActivity());
    }
        
    /**
     * The Promotions endpoint returns information about the promotion that will be available to a new user based on their activity's location. These promotions do not apply for existing users.
     * @param  array  $options    Array with all options for search
     * @param  double     $options['endLatitude']         Required parameter: Latitude component of end location.
     * @param  double     $options['endLongitude']        Required parameter: Longitude component of end location.
     * @param  double     $options['startLatitude']       Required parameter: Latitude component of start location.
     * @param  double     $options['startLongitude']      Required parameter: Longitude component of start location
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getPromotions (
                $options) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/v1/promotions';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'end_latitude'    => $this->val($options, 'endLatitude'),
            'end_longitude'   => $this->val($options, 'endLongitude'),
            'start_latitude'  => $this->val($options, 'startLatitude'),
            'start_longitude' => $this->val($options, 'startLongitude'),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //set HTTP basic auth parameters
        Request::auth(Configuration::$basicAuthUserName, Configuration::$basicAuthPassword);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new APIException('Malformed request.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new APIException('Unauthorized the request requires user authentication (not logged in).', $_httpContext);
        }

        else if ($response->code == 403) {
            throw new APIException('Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new APIException('Not found.', $_httpContext);
        }

        else if ($response->code == 406) {
            throw new APIException('Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', $_httpContext);
        }

        else if ($response->code == 409) {
            throw new APIException('A conflict needs to be resolved before the request can be made.', $_httpContext);
        }

        else if ($response->code == 422) {
            throw new APIException('Invalid request. The request body is parse-able however with invalid content or there are issues with a rider\'s user account.', $_httpContext);
        }

        else if ($response->code == 429) {
            throw new APIException('Too Many Requests. Rate limited', $_httpContext);
        }

        else if ($response->code == 500) {
            throw new APIException('Internal Server Error.', $_httpContext);
        }

        else if ($response->code == 222) {
            throw new APIException('bac', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\PromotionsResponse());
    }
        
    /**
     * The Request endpoint allows a ride to be requested on behalf of an Uber user given their desired product, start, and end locations. Please review the Sandbox documentation on how to develop and test against these endpoints without making real-world Requests and being charged.
     * @param  Models\RequestBody $body     Required parameter: Example: 
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createRequest (
                $body) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/v1/requests';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //set HTTP basic auth parameters
        Request::auth(Configuration::$basicAuthUserName, Configuration::$basicAuthPassword);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new APIException('Malformed request', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new APIException('Unauthorized the request requires user authentication (not logged in).', $_httpContext);
        }

        else if ($response->code == 403) {
            throw new APIException('Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new APIException('Not found', $_httpContext);
        }

        else if ($response->code == 406) {
            throw new APIException('Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json', $_httpContext);
        }

        else if ($response->code == 409) {
            throw new APIException('A conflict needs to be resolved before the request can be made.', $_httpContext);
        }

        else if ($response->code == 422) {
            throw new APIException('Invalid request. The request body is parse-able however with invalid content or there are issues with a rider\'s user account.', $_httpContext);
        }

        else if ($response->code == 429) {
            throw new APIException('Too Many Requests. Rate limited.', $_httpContext);
        }

        else if ($response->code == 500) {
            throw new APIException('Internal Server Error.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\Request());
    }
        
    /**
     * Get product details w.r.t id
     * @param  string     $productId      Required parameter: Unique identifier representing a specific product for a given latitude & longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProductDetailByID (
                $productId) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/v1/products/{product_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'product_id' => $productId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //set HTTP basic auth parameters
        Request::auth(Configuration::$basicAuthUserName, Configuration::$basicAuthPassword);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\Product());
    }
        


    /**
	 * Array access utility method
     * @param  array          $arr         Array of values to read from
     * @param  string         $key         Key to get the value from the array
     * @param  mixed|null     $default     Default value to use if the key was not found
     * @return mixed
     */
    private function val($arr, $key, $default = NULL)
    {
        if(isset($arr[$key])) {
            return is_bool($arr[$key]) ? var_export($arr[$key], true) : $arr[$key];
        }
        return $default;
    }

}